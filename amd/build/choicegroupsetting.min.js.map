{"version":3,"file":"choicegroupsetting.min.js","sources":["../src/choicegroupsetting.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Choice group settings JavaScript module\n *\n * @copyright  2025 UNIL\n * @author     Pierre Guarnieri <pierre.guarnieri@unil.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine(function() {\n\n    return {\n        init: function(param) {\n\n            const availableSelect = document.getElementById('availablegroups');\n            const selectedSelect = document.getElementById('id_selectedGroups');\n            const addBtn = document.getElementById('addGroupButton');\n            const removeBtn = document.getElementById('removeGroupButton');\n            const expandAllBtn = document.getElementById('expandButton');\n            const collapseAllBtn = document.getElementById('collapseButton');\n            const form = document.getElementById(param.formid);\n            const serializedselectedgroups = document.getElementById('serializedselectedgroups');\n            const ARROW_DOWN = '\\u25BC';\n            const ARROW_RIGHT = '\\u25B6';\n            const removedOptionsMap = new Map(); // Used to store options states when toggle grouping\n            let sortBy = param.sortgroupsby;\n\n            // Store original indexes states\n            Array.from(availableSelect.options).forEach((opt, index) => {\n                opt.dataset.originalIndex = index;\n            });\n\n            // On form load\n            if (serializedselectedgroups.value !== '') {\n                let selectedGroups = serializedselectedgroups.value.split(';').filter(n => n !== '');\n                let inSelected = [];\n\n                Array.from(availableSelect.options).forEach(opt => {\n                    if (opt.classList.contains('group') && !inSelected.includes(opt.value)) {\n                        opt.selected = selectedGroups.includes(opt.value);\n                        inSelected.push(opt.value);\n                    }\n                });\n\n                moveToSelected();\n            }\n\n            // Check if elements exist\n            if (!availableSelect || !selectedSelect) {\n                return;\n            }\n\n            let groupingStates = {};\n\n            // Initialize grouping states\n            Array.from(availableSelect.options).forEach(opt => {\n                if (opt.classList.contains('grouping')) {\n                    groupingStates[opt.value] = true;\n                }\n            });\n\n            // Setup event listeners\n            setupEventListeners();\n\n            /**\n             * Setup Events\n             */\n            function setupEventListeners() {\n                availableSelect.addEventListener('dblclick', function(e) {\n                    const clickedIndex = e.currentTarget.selectedIndex;\n                    if (clickedIndex >= 0) {\n                        const option = this.options[clickedIndex];\n                        if (option && option.classList.contains('grouping')) {\n                            e.preventDefault();\n                            toggleGrouping(option);\n                        } else if (option && option.classList.contains('group')) {\n                            e.preventDefault();\n                            moveToSelected();\n                        }\n                    }\n                });\n\n                selectedSelect.addEventListener('dblclick', function(e) {\n                    const clickedIndex = e.currentTarget.selectedIndex;\n                    if (clickedIndex >= 0) {\n                        e.preventDefault();\n                        moveToAvailable();\n                    }\n                });\n\n                if (addBtn) {\n                    addBtn.addEventListener('click', moveToSelected);\n                }\n\n                if (removeBtn) {\n                    removeBtn.addEventListener('click', moveToAvailable);\n                }\n\n                if (expandAllBtn) {\n                    expandAllBtn.addEventListener('click', expandAll);\n                }\n\n                if (collapseAllBtn) {\n                    collapseAllBtn.addEventListener('click', collapseAll);\n                }\n\n                form.addEventListener('submit', function(e) {\n                    if (selectedSelect.options.length < 1 && !window.skipClientValidation) {\n                        alert(M.util.get_string('pleaseselectonegroup', 'choicegroup'));\n                        e.preventDefault();\n                        e.stopPropagation();\n                        return;\n                    }\n\n                    let serializedSelection = '';\n                    selectedSelect.options.forEach(option => {\n                        serializedSelection += ';' + option.value;\n                    });\n\n                    serializedselectedgroups.value = serializedSelection;\n                });\n\n            }\n\n            /**\n             * Handle grouping option expansion or movement.\n             * @param {HTMLOptionElement} groupingOption - The grouping option element.\n             */\n            function toggleGrouping(groupingOption) {\n                const groupingValue = groupingOption.value;\n                groupingStates[groupingValue] = !groupingStates[groupingValue];\n\n                const isExpanded = groupingStates[groupingValue];\n                const currentText = groupingOption.textContent;\n                groupingOption.textContent = currentText.replace(/^[\\u25BC\\u25B6]/, isExpanded ? ARROW_DOWN : ARROW_RIGHT);\n\n                if (isExpanded) {\n                    const removedOptions = removedOptionsMap.get(groupingValue);\n                    if (removedOptions && removedOptions.length > 0) {\n                        const groupingIndex = Array.from(availableSelect.options).indexOf(groupingOption);\n                        removedOptions.forEach((option, i) => {\n                            const insertPosition = groupingIndex + 1 + i;\n                            if (insertPosition < availableSelect.options.length) {\n                                availableSelect.add(option, insertPosition);\n                            } else {\n                                availableSelect.add(option);\n                            }\n                        });\n\n                        removedOptionsMap.delete(groupingValue);\n                    }\n                } else {\n                    const groupingIndex = Array.from(availableSelect.options).indexOf(groupingOption);\n                    const optionsToRemove = [];\n                    let nextIndex = groupingIndex + 1;\n\n                    while (nextIndex < availableSelect.options.length) {\n                        const nextOption = availableSelect.options[nextIndex];\n\n                        if (nextOption.classList.contains('grouping')) {\n                            break;\n                        }\n\n                        if (nextOption.classList.contains('nested')) {\n                            optionsToRemove.push(nextOption);\n                        }\n\n                        nextIndex++;\n                    }\n\n                    for (let i = optionsToRemove.length - 1; i >= 0; i--) {\n                        optionsToRemove[i].remove();\n                    }\n\n                    removedOptionsMap.set(groupingValue, optionsToRemove);\n                }\n            }\n\n            /**\n             * Expand all groupings\n             */\n            function expandAll() {\n                const groupingOptions = Array.from(availableSelect.options).filter(opt =>\n                    opt.classList.contains('grouping')\n                );\n\n                groupingOptions.forEach(opt => {\n                    if (!groupingStates[opt.value]) {\n                        toggleGrouping(opt);\n                    }\n                });\n            }\n\n            /**\n             * Collapse all groupings\n             */\n            function collapseAll() {\n                const groupingOptions = Array.from(availableSelect.options).filter(opt =>\n                    opt.classList.contains('grouping')\n                );\n\n                groupingOptions.forEach(opt => {\n                    if (groupingStates[opt.value]) {\n                        toggleGrouping(opt);\n                    }\n                });\n            }\n\n            /**\n             * Move to Selected Groups\n             */\n            function moveToSelected() {\n                const data = [];\n                const usedValues = [];\n\n                Array.from(availableSelect.selectedOptions).forEach(selectedOpt => {\n                    if (selectedOpt.classList.contains('group') && !usedValues.includes(selectedOpt.value)) {\n                        const options = findAllOptions(availableSelect, selectedOpt.value, 'group');\n                        const originalIndexes = options.map(o => Number(o.dataset.originalIndex));\n\n                        selectedOpt.dataset.originalIndexes = JSON.stringify(originalIndexes);\n                        usedValues.push(selectedOpt.value);\n                        data.push(selectedOpt);\n                    }\n                });\n\n                data.forEach(opt => {\n                    selectedSelect.appendChild(opt);\n                    opt.selected = false;\n                    findAllOptions(availableSelect, opt.value, 'group').forEach(optToRemove => optToRemove.remove());\n                });\n\n                const sortedOptions = Array.from(selectedSelect.options).sort((a, b) => {\n                    if (sortBy === 'name') {\n                        return a.text.localeCompare(b.text);\n                    } else if (sortBy === 'timecreated') {\n                        // Assumes timecreated is stored as a data attribute\n                        const timeA = Number(a.dataset.timecreated || 0);\n                        const timeB = Number(b.dataset.timecreated || 0);\n                        return timeA - timeB;\n                    }\n                    return 0;\n                });\n\n                sortedOptions.forEach(opt => selectedSelect.appendChild(opt));\n            }\n\n            /**\n             * Move to Available groups\n             */\n            function moveToAvailable() {\n                const toRestore = [];\n\n                Array.from(selectedSelect.selectedOptions).forEach(opt => {\n                    const originalIndexes = JSON.parse(opt.dataset.originalIndexes || `[${opt.dataset.originalIndex || -1}]`);\n                    opt.remove();\n\n                    originalIndexes.forEach((origIndex, idx) => {\n                        const newOpt = idx === 0 ? opt : opt.cloneNode(true);\n                        newOpt.removeAttribute('id');\n                        newOpt.dataset.originalIndex = String(origIndex);\n                        newOpt.dataset.originalIndexes = JSON.stringify(originalIndexes);\n\n                        toRestore.push({ index: Number(origIndex), option: newOpt });\n                    });\n                });\n\n                toRestore.sort((a, b) => a.index - b.index);\n\n                toRestore.forEach(({ index, option }) => {\n                    const nextOpt = Array.from(availableSelect.options).find(o => Number(o.dataset.originalIndex) > index);\n                    if (nextOpt) {\n                        availableSelect.add(option, nextOpt);\n                    } else {\n                        availableSelect.add(option);\n                    }\n                    option.selected = false;\n                });\n            }\n\n            /**\n             * Find all <option> elements in a select that match a given value and optional class.\n             * @param {HTMLSelectElement} selectElement - The select element to search within.\n             * @param {string} value - The option value to match.\n             * @param {string|null} [className=null] - Optional class name to filter by.\n             * @returns {HTMLOptionElement[]} The matching option elements.\n             */\n            function findAllOptions(selectElement, value, className = null) {\n                return Array.from(selectElement.options).filter(opt => {\n                    return opt.value === value && (!className || opt.classList.contains(className));\n                });\n            }\n        }\n    };\n});"],"names":["define","init","param","availableSelect","document","getElementById","selectedSelect","addBtn","removeBtn","expandAllBtn","collapseAllBtn","form","formid","serializedselectedgroups","removedOptionsMap","Map","sortBy","sortgroupsby","Array","from","options","forEach","opt","index","dataset","originalIndex","value","selectedGroups","split","filter","n","inSelected","classList","contains","includes","selected","push","moveToSelected","groupingStates","toggleGrouping","groupingOption","groupingValue","isExpanded","currentText","textContent","replace","removedOptions","get","length","groupingIndex","indexOf","option","i","insertPosition","add","delete","optionsToRemove","nextIndex","nextOption","remove","set","expandAll","collapseAll","data","usedValues","selectedOptions","selectedOpt","originalIndexes","findAllOptions","map","o","Number","JSON","stringify","appendChild","optToRemove","sort","a","b","text","localeCompare","timecreated","moveToAvailable","toRestore","parse","origIndex","idx","newOpt","cloneNode","removeAttribute","String","_ref","nextOpt","find","selectElement","className","addEventListener","e","clickedIndex","currentTarget","selectedIndex","this","preventDefault","window","skipClientValidation","alert","M","util","get_string","stopPropagation","serializedSelection","setupEventListeners"],"mappings":"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"}